<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小皮</title>
  
  <subtitle>The quieter you becom, the more you are able to hear</subtitle>
  <link href="http://xiaopi826.github.io/atom.xml" rel="self"/>
  
  <link href="http://xiaopi826.github.io/"/>
  <updated>2023-05-18T15:39:58.930Z</updated>
  <id>http://xiaopi826.github.io/</id>
  
  <author>
    <name>小皮</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NTLM与Kerberos协议</title>
    <link href="http://xiaopi826.github.io/2023/05/18/ntlm-yu-kerberos-xie-yi/"/>
    <id>http://xiaopi826.github.io/2023/05/18/ntlm-yu-kerberos-xie-yi/</id>
    <published>2023-05-18T09:31:18.000Z</published>
    <updated>2023-05-18T15:39:58.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、NTLM协议"><a href="#一、NTLM协议" class="headerlink" title="一、NTLM协议"></a>一、NTLM协议</h2><p>NTLM（NewTechnology LAN Manager）协议是微软用于windows身份验证的主要协议之一。NTLM协议可用于工作组中的机器验证，又可用于域环境身份验证，还可为SMB、HTTP、LDAP、SMTP等上层微软应用提供身份验证。</p><h3 id="0x01-NTLM-Hash加密流程"><a href="#0x01-NTLM-Hash加密流程" class="headerlink" title="0x01 NTLM Hash加密流程"></a>0x01 NTLM Hash加密流程</h3><p>以760170为例</p><p>1）将用户密码转换为十六进制格式</p><pre class="line-numbers language-none"><code class="language-none">760170 -&gt; 转为十六进制 = 373630313730<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2）将ASCII码的十六进制，即在每个字节之后添加0x00</p><pre class="line-numbers language-none"><code class="language-none">373630313730 -&gt; 转为Unicode编码 = 370036003000310037003000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3）对Unicode编码的十六进制字符串进行MD4单向Hash加密。</p><pre class="line-numbers language-none"><code class="language-none">370036003000310037003000 -&gt; MD4加密 c908eb113f657fd0a03f386cadc14ceb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="0x02-NTLM-Hash本地认证流程"><a href="#0x02-NTLM-Hash本地认证流程" class="headerlink" title="0x02 NTLM Hash本地认证流程"></a>0x02 NTLM Hash本地认证流程</h3><p>用户密码经过NTLM Hash加密后存储在C:\Windows\System32\config\SAM 文件中</p><p>在本地登录Windows的情况下，操作系统会使用用户输入的密码转为NTLM Hash后，去与SAM文件中的NTLM Hash密码进行比较。</p><p>大致流程为：</p><pre class="line-numbers language-none"><code class="language-none">winlogon.exe -&gt; 接收用户输入 -&gt; lsass.exe -&gt; 转为Hash对比SAM文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当用户注销、重启、锁屏后，操作系统会让 winlogon.exe 显示登录页面，当 winlogon.exe 接收用户输入后，将密码交给 lsass.exe 进程，lsass.exe进程中会存一份明文密码，将明文密码加密成 NTLM Hash 后与 SAM 文件进行比较认证。mimikatz 就是从lsass.exe 进程中抓取明文密码或者 Hash 密码。</p><p>mimikatz读取用户密码</p><p>提升权限</p><pre class="line-numbers language-none"><code class="language-none">privilege::debug<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/./../images/NTLM%E4%B8%8EKerberos%E5%8D%8F%E8%AE%AE%E5%9B%BE%E7%89%87/Snipaste_2023-05-18_17-18-59.png" alt="Snipaste_2023-05-18_17-18-59"></p><p>读取密码</p><pre class="line-numbers language-none"><code class="language-none">sekurlsa::logonPasswords<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/./../images/NTLM%E4%B8%8EKerberos%E5%8D%8F%E8%AE%AE%E5%9B%BE%E7%89%87/Snipaste_2023-05-18_17-19-32.png" alt="Snipaste_2023-05-18_17-19-32"></p><h3 id="0x03-NTLM-Hash协议认证"><a href="#0x03-NTLM-Hash协议认证" class="headerlink" title="0x03 NTLM Hash协议认证"></a>0x03 NTLM Hash协议认证</h3><p>NTLM协议是一种基于 Challenge/Response（质询/响应）的验证机制，由三种类型消息组成：</p><p>Type1（协商，Negotiate）</p><p>Type2（质询，Challenge）</p><p>Type3（认证，Authentication）</p><h4 id="1）工作组环境下的NTLM认证"><a href="#1）工作组环境下的NTLM认证" class="headerlink" title="1）工作组环境下的NTLM认证"></a>1）工作组环境下的NTLM认证</h4><p><img src="/./../images/NTLM%E4%B8%8EKerberos%E5%8D%8F%E8%AE%AE%E5%9B%BE%E7%89%87/QQ%E6%88%AA%E5%9B%BE20230518210552.png" alt="QQ截图20230518210552"></p><p>完整认证流程</p><ol><li>用户登录后，客户端缓存服务器密码的 NTLM Hash 值，然后客户端向服务器发送请求，请求利用 NTLM SSP 生成 NTLMSSP_NEGOTIATE 消息（简称Type1 协商消息）</li><li>服务端接收到Type1协商消息后，读取其中的内容，选择能接受的服务内容传入NTLM SSP，得到 NTLMSSP_CHALLENGE 消息（简称Type2 质询消息），并将Type2质询消息返回给客户端。Type2质询消息里有服务端生成的16位随机值，被称为 Challenge 值，服务端会将 Challenge 值进行缓存。</li><li>客户端收到Type2质询消息，取出 Challenge 值，用缓存服务器密码的 NTLM Hash 对 Challenge 值进行加密得到 Response 消息。然后将 Response 和其他信息封装到 NTLMSSP_AUTH 中（简称Type3 认证消息）发往服务端。</li><li>服务端接收到Type3认证消息后，取出 Net-NTLM Hash，然后用自己密码的 NTLM Hash 对 Challenge 值进行一系列加密运算，得到服务端计算的 Net-NTLM Hash，并与客户端的 Net-NTLM Hash 进行比较，相等则认证成功。</li></ol><h4 id="2）-域环境下的NTLM认证"><a href="#2）-域环境下的NTLM认证" class="headerlink" title="2） 域环境下的NTLM认证"></a>2） 域环境下的NTLM认证</h4><p><img src="/./../images/NTLM%E4%B8%8EKerberos%E5%8D%8F%E8%AE%AE%E5%9B%BE%E7%89%87/Snipaste_2023-05-18_21-16-13.png" alt="Snipaste_2023-05-18_21-16-13"></p><p>完整认证流程</p><p>1）用户登录后，客户端缓存服务器密码的 NTLM Hash 值。然后客户端向服务器发送请求，请求利用 NTLM SSP 生成 NTLMSSP_NEGOTIATE 消息（简称Type1 协商消息）</p><p>2）服务端接收到Type1协商消息后，读取其中的内容，选择能接受的服务内容传入NTLM SSP，得到 NTLMSSP_CHALLENGE 消息（简称Type2 质询消息），并将Type2质询消息返回给客户端。Type2质询消息里有服务端生成的16位随机值，被称为 Challenge 值，服务端会将 Challenge 值进行缓存。</p><p>3）客户端收到Type2质询消息，取出 Challenge 值，用缓存服务器密码的 NTLM Hash 对 Challenge 值进行加密得到 Response 消息。然后将 Response 和其他信息封装到 NTLMSSP_AUTH 中（简称Type3 认证消息）发往服务端。</p><p>4）服务端接收到Type3认证消息后，通过 Netlogon 协议与域控(Domain Controller)建立一个安全通道，将验证消息发送给域控。</p><p>5）域控收到服务器端发送的Type3认证消息，取出Net-NTLM Hash。然后从数据库中找到该用户的 NTLM Hash，对 Challenge 进行一系列加密运算，得到域控计算的Net-NTLM Hash  并与服务器端发送的Net-NTLM Hash进行比较，相等则认证成功，并将判断结果发送给服务端。</p><p>6）服务器端根据域控返回结果，对客户端进行回复。</p><h4 id="3）NTLM-v2协议"><a href="#3）NTLM-v2协议" class="headerlink" title="3）NTLM v2协议"></a>3）NTLM v2协议</h4><p>NTLM v1 和 NTLM v2 最显著的区别就是 Challenge 值与加密算法不同，共同点是都使用 NTLM Hash 进行加密。</p><p>Challenge 值：</p><pre class="line-numbers language-none"><code class="language-none">NTLM v1：8位NTLM v2：16位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Net-NTLM Hash 使用的加密算法：</p><pre class="line-numbers language-none"><code class="language-none">NTLM v1：DES加密算法NTLM v2：HMAC-MD5 加密算法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="二、Kerberos协议"><a href="#二、Kerberos协议" class="headerlink" title="二、Kerberos协议"></a>二、Kerberos协议</h2><p>Kerberos协议是一种网络身份验证协议，它旨在使用密钥加密技术为客户端/服务端应用程序提供强身份验证，需要三方共同参与才能完成一次认证。kerberos是域环境下的主要身份认证机制。</p><h3 id="0x01-Kerberos认证结构"><a href="#0x01-Kerberos认证结构" class="headerlink" title="0x01 Kerberos认证结构"></a>0x01 Kerberos认证结构</h3><p>Kerberos认证所需的三个角色</p><ol><li>客户端：代表用户，用户有自己的密码,server上运行的服务也有自己的密码,KDC是受信任的第三方认证中心,它拥有用户和服务的密码信息</li><li>服务器端：代表域控，域控当中存储了域内管理员与账户的信息,所有域内账户的认证和相关的密码策略都由域控来进行管理和控制,域控充当着门卫的角色。</li><li>提供认证服务的KDC（Key Distribution Center，密钥分发中心）：KDC是一种网络服务，在域环境中，KDC服务默认会安装在域控中，客户端如果想访问服务器的服务，前提是需要通过KDC认证，再由KDC的票据决定客户端是否有权限访问服务器的服务。</li></ol><p>Kerberos是一种基于票据（Ticket）的认证方式。客户端想要访问服务端的某个服务，首先需要购买服务端认可的ST（Service Ticket，服务票据）。也就是说，客户端在访问服务之前要买票，验票之后才能访问。但是这个票需要TGT（Ticket Granting Ticket，认购权证）。TGT 和 ST 都由 KDC 发放，但是KDC运行在域控上，所以说TGT和ST都有域控发放。</p><h3 id="0x02-Kerberos简单认证流程"><a href="#0x02-Kerberos简单认证流程" class="headerlink" title="0x02 Kerberos简单认证流程"></a>0x02 Kerberos简单认证流程</h3><p><img src="/./../images/NTLM%E4%B8%8EKerberos%E5%8D%8F%E8%AE%AE%E5%9B%BE%E7%89%87/image-20220916162410529.png" alt="image-20220916162410529"></p><p>Client想要访问Server的某个服务，就需要通过KDC的认证，获取到服务票据（ST），服务会验证服务票据（ST）来判断Client是否通过了KDC认证。为了避免Client每次访问Server的服务都要向KDC认证(输入密码)，KDC设计时分成了两个部分，一个是AS，另一个是TGS;AS接收Client的认证信息，认证通过后给Client发放一个可重复使用的票据TGT，后续Client使用这个TGT向TGS请求ST即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、NTLM协议&quot;&gt;&lt;a href=&quot;#一、NTLM协议&quot; class=&quot;headerlink&quot; title=&quot;一、NTLM协议&quot;&gt;&lt;/a&gt;一、NTLM协议&lt;/h2&gt;&lt;p&gt;NTLM（NewTechnology LAN Manager）协议是微软用于windows身</summary>
      
    
    
    
    <category term="内网" scheme="http://xiaopi826.github.io/categories/%E5%86%85%E7%BD%91/"/>
    
    
    <category term="Windows协议" scheme="http://xiaopi826.github.io/tags/Windows%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://xiaopi826.github.io/2022/09/25/test/"/>
    <id>http://xiaopi826.github.io/2022/09/25/test/</id>
    <published>2022-09-25T11:24:01.000Z</published>
    <updated>2022-09-26T06:25:44.000Z</updated>
    
    
    
    
    <category term="test111" scheme="http://xiaopi826.github.io/categories/test111/"/>
    
    
    <category term="test1" scheme="http://xiaopi826.github.io/tags/test1/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://xiaopi826.github.io/2022/09/24/hello-world/"/>
    <id>http://xiaopi826.github.io/2022/09/24/hello-world/</id>
    <published>2022-09-24T04:47:26.700Z</published>
    <updated>2022-09-24T04:47:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
